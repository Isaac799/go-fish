# Go Fish

a fish themed ssr framework using go templating

## Complementary

Consider using htmlx as it works great for this sort of thing. I kept it in the example.

## Concepts

Simply write go code, and dump templates and assets into directories. 
- dir = pond
- dir item = fish

### Pond

A pond is a collection of fish.

In a pond we can:
- restrict access to fish in the pond via 'before catch fns' (middleware that applies to all endpoints)
- provide shad (small fish) to be eaten by other fish in the pond (dependents for use in html doc head or template execution)
- specify chum bait (data provided to all templates before execution)

A pond is created by pointing at a directory. It is looked through and fish are created.

### Fish

A item discovered in the ponds.

In a fish we have:
- school are other fish available to it (files found in the same dir)
- coral is the details of a fish (the bytes of file)
- reef combination of all coral for a fish (combination of all templates bytes for template parsing)
- bobber stays above a tuna. (head of the html document, determined by other file in dir or globally scoped)
- restrict access to catch via 'before catch fns' (middleware)
- provide bait (data provided to just this template before execution)
- specify tackle to help catch a fish (the template func map for use in template parse)

Here is more specifics about the fish.

- **Tuna** is a big fish. Served as a page. Consumes Sardines
	- Identified by mime `[ text/html ]`
	- Not cached
- **Sardine** is a small fish. Used by tuna. Smaller templates, served standalone too
	- Identified by mime `[ text/html ]` & `_` name prefix
	- Children of a tuna share its bait
	- Not cached
- **Clown** is a decorative fish. Used in head of document
	- Identified by mime `[ text/css | text/javascript ]`
	- Is cached & use version as hash
- **Anchovy** is supportive of the tuna
	- Identified by mime `[ image | audio | video ]`
	- Is cached

### Stocking a Pond

With a application largely generated by what is in a directory I needed a way to enable developer to enforce specifics. The solution I landed on was to simply stock a pond with fish (a map of regex->fish). Regex is used to match file paths in the directory so I know what fish to target. The stock fish you give is then gobbled up by the fish in the pond, so the pond fish inherit its traits (BeforeCatch, Tackle, and OnCatch). The other fish 
in a school also gobble it up (giving sardines the ability to render standalone).

## Example

See the example folder

## Path Value

For a file name, `.` delimited makes a new path. This is designed with path values in mind, and not to be used in place of dir structure. The even items are considered a value, enforcing a `/context/value` pattern. 

To use path values simply name a file like: 
- `user.id.html` translates to `/user/{id}`
- `user.id.edit.html` translates to `/user/{id}/edit`

Or this too works
- `user/user.html` translates to `/user`
- `user/.id.html` translates to `/user/{id}`
- `user/.id.edit.html` translates to `/user/{id}/edit`

How is this useful? 
- You can use the `id` in the 'before catch' to restrict access
- You can use the `id` in the bait to lookup a user to help render.

Note a file named the same as its dir is the landing page for that pattern. So if `users/user.html` that is the template used when visiting `/user` in the browser.

## Naming

Name things whatever you like, put them wherever you like. Just know this:

- **Patterns** to for mux to match are lower kebab case. So if a file is called `My photo.jpg` I will recognize that to `my-photo.jpg`.
- **Template Names** are the same as file, without extension. You **do not** need to `{{ define "foo" }} ... {{ end }}` in your templates. I do this before the template is executed to enforce the standard. Examples: 
  - `_nav.html` is accessible via `{{ template "_nav" }}`
  - `user.id.edit.html` is accessible via `{{ template "user.id.edit" }}`


### Go

In the go code here is the flow:

1. **Define** the element, include any hidden inputs desired for preserved state between refreshes.
2. **Populate** the elements input fields by passing the request into the element. One function - sweet! Oh and its super safe too - ignoring malformed submission values. So once step 3 comes up, we are golden.
4. **Modify** the element based on its values. Value access made easy with functions on element. 

With this flow I was able to make a stateful table that has per column filtering and sorting, dynamic pagination, and row limitations.
